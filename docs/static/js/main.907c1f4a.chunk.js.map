{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","category","console","log","type","value","onChange","target","GifGridItem","title","url","className","src","alt","getGifs","a","fetch","response","json","data","gifs","map","img","id","images","downsized_medium","GifGrid","loading","state","setState","useEffect","then","imgs","setTimeout","useFetchGifs","image","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAMaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAAmB,EAMRC,mBAAS,IAND,mBAMrCC,EANqC,KAMzBC,EANyB,KA+B5C,OACI,sBAAMC,SAbW,SAACC,GAClBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,GAG3BR,GAAc,SAAAS,GAAQ,OAAKP,GAAL,mBAAoBO,OAG9CC,QAAQC,IAAI,mBAIZ,SACI,uBACIC,KAAK,OACLC,MAAOX,EACPY,SAzBc,SAACT,GACvBF,EAAcE,EAAEU,OAAOF,a,QChBlBG,EAAc,SAAC,GAAkB,IAAjBC,EAAgB,EAAhBA,MAAOC,EAAS,EAATA,IAEhC,OACI,sBAAKC,UAAU,6CAAf,UACI,qBAAKC,IAAKF,EAAKG,IAAKJ,IACpB,4BAAIA,Q,uBCLHK,EAAO,uCAAG,WAAMb,GAAN,uBAAAc,EAAA,6DAEbL,EAFa,iDAEmCT,EAFnC,+DAGIe,MAAMN,GAHV,cAGbO,EAHa,gBAIEA,EAASC,OAJX,uBAIZC,EAJY,EAIZA,KAEDC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRd,MAAOa,EAAIb,MACXC,IAAG,UAAEY,EAAIE,cAAN,aAAE,EAAYC,iBAAiBf,QAVvB,kBAcZU,GAdY,4CAAH,sDCGPM,EAAU,SAAC,GAAgB,IAAfzB,EAAc,EAAdA,SAAc,ECKX,SAACA,GAAc,IAAD,EAEZR,mBAAS,CAC/B0B,KAAM,GACNQ,SAAS,IAJyB,mBAE/BC,EAF+B,KAExBC,EAFwB,KAoBtC,OAbAC,qBAAU,WAENhB,EAAQb,GACH8B,MAAK,SAAAC,GACFC,YAAW,WACPJ,EAAS,CACLV,KAAMa,EACNL,SAAS,MAEd,UAEZ,CAAC1B,IAEG2B,EDrBwBM,CAAajC,GAAhCuB,EAJuB,EAI5BL,KAAaQ,EAJe,EAIfA,QAapB,OACI,qCACI,6BAAK1B,IAEJ0B,GAAW,wCAQX,qBAAKhB,UAAU,YAAf,SAGOa,EAAOH,KAAK,SAAAc,GAAK,OACT,cAAC,EAAD,eAEQA,GADCA,EAAMZ,aEnC9Ba,EAAe,WAAM,MAMM3C,mBAAS,CAAC,eANhB,mBAMvB4C,EANuB,KAMX7C,EANW,KAQ9B,OACI,gCACI,8CACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAEA,6BAUQ6C,EAAWhB,KAAI,SAAApB,GAAQ,OACvB,cAAC,EAAD,CAEIA,SAAUA,GADLA,Y,MCzB7BqC,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.907c1f4a.chunk.js","sourcesContent":["import React, {useState} from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\n// the props 'setCategories' are destructured before being used on the component, done that we can call the \r\n// setCategories function from the parent component to properly add the input value into the string array declared\r\n// on it\r\nexport const AddCategory = ({setCategories}) => {\r\n    \r\n    // the inputValue by default wll be left as an empty string on the useState, if we remove the \r\n    // quotation marks then the browser will send an error, the error will not be explicit but it will be\r\n    // a reference to the inputValue object stating that it is in an undefined state, when the \r\n    // quotation marks are placed on the useState then the error will disappear\r\n    const [inputValue, setInputValue] = useState('');\r\n\r\n    // this function will retrieve the value placed in the input box, done by calling the event, \r\n    // then the target value will contain the input value which will be assigned to the inputValue\r\n    // object which we will use to include into the categories from the previous component\r\n    const handleInputChange = (e) => {\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    // we use the handleSubmit function to first prevent the input box from having an unrequired submission\r\n    // with an incorrect input, then we check if the input value is greater than 2 characters, if its true\r\n    // then the prop setCategories from the previous component is called for it to include the string input in\r\n    // the categories object\r\n    const handleSubmit = (e) => {\r\n        e.preventDefault();\r\n\r\n        if (inputValue.trim().length > 2){\r\n            // inputvalue is placed first for it to push the other results to the bottom on the screen and have\r\n            // the new results for quick reading\r\n            setCategories(category => [inputValue, ...category])\r\n        }\r\n        \r\n        console.log('Submit succeed')\r\n    }\r\n\r\n    return (\r\n        <form onSubmit={handleSubmit}>\r\n            <input\r\n                type=\"text\"\r\n                value={inputValue}\r\n                onChange={handleInputChange}\r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\n// the PropTypes will send an error on the browser console if the AddCategory component is used\r\n// without the setCategories sent as an argument, this will add a security layer which will allow\r\n// to only make modifications to a get or post request under our rules\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}","import React from 'react';\r\n\r\nexport const GifGridItem = ({title, url}) => {\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeInLeft\">\r\n            <img src={url} alt={title}/>\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n ","\r\n\r\nexport const getGifs = async(category) => {\r\n\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${category}&api_key=2PXxOmvq8Coc37511QZVmrmpimC4BAZy&limit=10`;\r\n    const response = await fetch(url);\r\n    const {data} = await response.json();\r\n\r\n    const gifs = data.map(img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    });\r\n\r\n    return gifs;\r\n}","import React from 'react'\r\n// import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n    // const [images, setImages] = useState([]);\r\n\r\n    const {data:images, loading} = useFetchGifs(category);\r\n\r\n    // // function run every time the component is loaded\r\n    // useEffect(() => {\r\n    //     getGifs(category)\r\n    //         .then(imgs => setImages(imgs));\r\n    //         // also .then(setImages);\r\n\r\n    // // in determined cases, the argument sent from the parent component might change instead of adding an additional\r\n    // // one, a warning will be sent through the console for us to acknowledge a lack of cohesion on the useEffect, in\r\n    // // this code we just need to add the category argument as a dependency inside the array at the end of the function     \r\n    // }, [category])\r\n\r\n    return (\r\n        <>\r\n            <h3>{category}</h3>\r\n\r\n            {loading && <p>Loading</p>}\r\n            {/* the operator && will work for us as an evaluation of a true/false statement, it can be used\r\n            instead of a ternary evaluation, the ternary option is placed below as example for a different approach.\r\n            {loading ? <p>Loading</p> : null}\r\n            */}\r\n\r\n            {/*we use className instead of class as javascript will give us a warning when rendering the tag, as \"class\"\r\n            is a reserved word for scripting uses*/}\r\n             <div className=\"card-grid\">\r\n                {\r\n                    \r\n                    images.map( image => (\r\n                            <GifGridItem \r\n                                key={image.id}\r\n                                {...image} />))\r\n                }\r\n            </div> \r\n        </>\r\n    )\r\n}\r\n","import { useState, useEffect } from \"react\";\r\nimport { getGifs } from \"../helpers/getGifs\";\r\n\r\n// custom hook created for it to load our API request with a custom loading state\r\n// the data will be an empty array with a loading state of 'true', when the setState \r\n// function will be used along with a useEffect which will be loaded every time a new \r\n// parameter is placed in the search bar, the component will then be loaded again with \r\n// new categories, which will be rendered again and the loading state will be false,\r\n// the setState is contained on a timeout function which will update itself after 3 seconds\r\n\r\nexport const useFetchGifs = (category) => {\r\n\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    useEffect(() => {\r\n        \r\n        getGifs(category)\r\n            .then(imgs => {\r\n                setTimeout(() => {\r\n                    setState({\r\n                        data: imgs,\r\n                        loading: false\r\n                    })\r\n                }, 1000)\r\n            })\r\n    }, [category])\r\n\r\n    return state;\r\n}\r\n","import React, { useState } from 'react'\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    // default element on our categories section is \"Death Note\", which is used to trigger the component into our webpage, as seen below,\r\n    // the setCategories function from our hook is being passed to the AddCategory script, which we will use to add additional elements to\r\n    // our string array, along with that, we are rendering the categories object with a GifGrid component for it to have an specific visual\r\n    // effect described on its script\r\n    const [categories, setCategories] = useState(['Death Note']);\r\n\r\n    return (\r\n        <div>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories={setCategories}/>\r\n            <hr />\r\n\r\n            <ol>\r\n\r\n                {/* returning a child in a list using methods like map should have an unique key, therefore, in this example i use\r\n                the category itself as identifier, but this method would not work if the list has an element with the same value, so i can\r\n                either use an additional parameter (the index, even its not so recommended) on the map method which would be read as \r\n                \".map((category, index))\" or, for future modifications to that list, i can use a hook instead, which will be called through a\r\n                click event by using the hook handler, then using the existing array of strings along with an ellipsis (...) and then to add\r\n                what i want, in this case another string appended at the end of the array.*/}\r\n                \r\n                { \r\n                    categories.map(category => (\r\n                    <GifGrid \r\n                        key={category}\r\n                        category={category}\r\n                    />))\r\n                }\r\n            </ol>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}